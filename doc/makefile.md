# Makefile Experiment

For historical and conformance reasons, tree-sitter-clojure's
repository has been using an `npm` / `package.json` organization.

We made use of the associated "scripts" (see inside of `package.json`)
functionality and relied on the capabilities of the command line
interface (cli) of `tree-sitter` for various project-related tasks
such as:

* Generating `.c` and `.json` bits from `grammar.js`
* Generating a `.wasm` file for the grammar
* Expressing and conducting light testing
* Arranging for and starting a local browser-based playground

There are other things that the arrangement provided which we may not
necessarily want to live within the repository going forward:

* Node.js bindings
* Rust bindings

Alternatives to the above arrangement were not really considered
initially.

This document contains notes about considering a different approach
based on using a `Makefile`.

## Background

### Some Drawbacks of `npm` / `package.json`

* Finding and understanding relevant information about how `npm` works
  and why it is behaving in a certain way appears to be unnecessarily
  difficult [1].

* No comments allowed in `package.json` because it's `.json`

* Poor stability of `npm `across upgrades (e.g. lock file version
  changes)

* Conceptually, `npm` / `package.json` has "scripts" that are not
  really targets (which could have other targets as dependencies)

* To execute a script in `npm` / `package.json`, one must `npm run
  <name>`, which is verbose if it's going to be used for performing
  actions repeatedly at the command line.

[1] For example, the presence of `binding.gyp` in the root of the
project directory leading to the execution of `node-gyp rebuild` upon
invocation of `npm install`, was not easy to find.  Note that the
starting point was "why is `npm install` doing X?" and that at the
time of this writing, [these
docs](https://docs.npmjs.com/cli/v6/commands/npm-install) don't
mention `node-gyp` or `binding.gyp`.

Also note that this file gets "magically" generated by the `generate`
subcommand of `tree-sitter` whose primary purpose IMO is to create
`src/parser.c`, `grammar.json`, and friends.  This will be covered
more later, but it is an example of some of the behavior by
`tree-sitter` which we want to avoid.  Thankfully with version 0.19.4
of `tree-sitter`, Node.js and Rust binding generation can be
suppressed via the `--no-bindings` flag.

### Why `package.json` Won't Be Removed At This Time

We may be able to stop using `npm`, but removing `package.json` would
likely break [one of our
users](https://github.com/cursorless-dev/vscode-parse-tree/) and the
`tree-sitter` cli actually is hard-wired to look for `package.json`
with some amount of content.

Although removal is not on the table at this time, its content can be
reduced the bare minimum of say:

```
{
  "name": "tree-sitter-clojure",
  "version": "0.0.9",
  "tree-sitter": [
    {
      "scope": "source.clojure",
      "file-types": [
        "bb",
        "clj",
        "cljc",
        "cljs"
      ]
    }
  ]
}
```

The `name` and `version` entries will satisfy our user's needs while
the `tree-sitter` entry will satisy the `tree-sitter` cli.

### Drawbacks of Some `tree-sitter` Subcommands

The `tree-sitter` cli has some functionality built in to it which may
provide a degree of convenience though may come with significant
drawbacks.

Some of its functionality can be provided for via `Makefile` targets
with appropriate dependencies and implementations.

Some examples include:

* Building the shared object

* Building the `.wasm` file

* Setting up and starting the playground

* Executing tests and reporting on the results

Customization and diagnosing issues may become significantly easier
with such an arrangement [1].

There is at least one thing that one may want to avoid for a common
set of uses cases involving trying to establish the behavior of one
specific grammar on its own (IMO, a common scenario).

Many `tree-sitter` subcommands can lead to scanning certain
directories for directories that have names beginning with
`tree-sitter-`.  This is done in order to locate grammars for various
programming languages for use by various `tree-sitter` subcommands.

`tree-sitter` will, if necessary, try to arrange for the compilation
and "installing" of corresponding shared objects based on what it
finds.

This can be convenient, but it can also be confusing if multiple
versions of a grammar are picked up [2] and an unexpected one is
compiled and installed for use.  Also, you might not know that
`tree-sitter` does this -- I didn't until I started investigating some
initially confusing results.

Where `tree-sitter` looks can be configured using an appropriate
configuration file, but at present, AFAIK, there is no way to turn off
the scanning, nor is there any feedback about which one it chose to
use.

Due to the above, an attempt will be made to gradually:

1. Externalize some of the current functionality of `tree-sitter`,
   likely in the form of `Makefile` targets

2. Arrange for avoidance or mitigation of the unwanted scanning.

[1] When trying to use a MSYS2 / MingW64 environment with
`tree-sitter`, one subcommand invocation was failing with output that
looked like compilation errors.  Investigation involved modifying
`tree-sitter` source to print out the compilation invocation,
recompiling `tree-sitter`, and repeating the original invocation.  It
turned out that an inappropriate compiler had been chosen.

Had this building process been expressed in a `Makefile`, the
activities involved for investigation likely would have been simpler
and taken less time.

[2] Haing multiple checkouts of a grammar doesn't seem like it could
be too unlikely because:

Different branches may be stored in separate directories with names
like `tree-sitter-<name>.branch-a` and `tree-sitter-<name>.branch-a`.

Even if you don't do that sort of thing, consider that you might clone
someone else's work.  Then having a directory name like
`tree-sitter-<name>.collaborator-handle` doesn't seem so unlikely.

Storing such directories under the same parent directory such as
`~/src` seems like a reasonable choice.

### Why a `Makefile`?

#### Some Reasons to Use a `Makefile`

* Entering full commands repeatedly can be error-prone and when
  returning to work on the project after not thinking about it for
  some time, details may be difficult / impractical to recall.  Some
  of the details may be captured usefully in a `Makefile` or something
  that it references.

* Abstracting tasks seems better handled by a `Makefile` rather than
  via a `package.json`'s "scripts" mechanism.  One benefit of this
  might be that reliance on some of `tree-sitter`'s features that
  involve side-effects (which can lead to confusion) can be reduced.

* Certain types of dependencies among targets can be expressed -- this
  doesn't seem practical or idiomatic with `package.json`'s "scripts"
  mechanism.

* Unlike `package.json`, a `Makefile` can contain comments, so some
  forms of documentation about certain things can live closer to where
  those things are expressed, in context.

* Behavior of `make` has been more stable over the recent past.  Note
  that the specific `make` in question is GNU's `make` (as there are
  other implementations too).

* We may be able to stop using `npm`.  Put briefly, this may mean
  meaningfully less time spent on incidental complexity.

#### Some Potential Issues

* Windows support may be less straight-forward than for *nix-like
  systems.  However, the current maintainers don't use Windows to
  develop tree-sitter-clojure, though efforts are made to make it
  possible.

* Makefiles can get complicated.  Keeping things reasonable and
  well-documented may be important.

### Scanning Mitigation

I tried to mitigate the effects of `tree-sitter`'s scanning so that it
doesn't go looking elsewhere (i.e. outside of a particular grammar's
project directory) for other `tree-sitter-` directories in an effort
to reduce confusion and lost time, effort, resources, and energy.
This may end up being a short-term work-around until a better approach
is found or devised.

There is a setting in `tree-sitter`'s `config.json` named
`parser-directories` that can be abused for this purpose.

By making `"."` the only element:

```json
{
  "parser-directories": [
    "."
  ],
```

the `tree-sitter` cli can be convinced to only scan immediately under
the current directory.

Further, inside the grammar's project directory, one can make a
symlink between `tree-sitter-<name>` and `.` (points at the grammar's
project directory itself).  So that the grammar project directory will
be picked up by the scanning.

The effect of these two is to make it possible to run `parse`,
`query`, and other `tree-sitter` subcommands (that can involve
scanning) to function if invoked inside the grammar's project
directory.

This hack currently works, but there appear to be at least 2 downsides
to this:

1. If working on Windows, one may need to make appropriate
   arrangements to handle symlinks.  Putting the account(?) in
   "Developer Mode" and tweaking git's settings `core.symlink = true`
   seems to be sufficient, but this may not be acceptable in certain
   scenarios.

2. It appears that yarn may have issues handling packages that contain
   symlinks in them:

   * https://github.com/yarnpkg/yarn/issues/3276
   * https://github.com/yarnpkg/yarn/issues/4293

   I tried the "reproducing" code in the first issue but it appears to
   have been addressed, so my case appears to be different.

   I experienced this trying to get
   [vscode-parse-tree](https://github.com/cursorless-dev/vscode-parse-tree/)
   (which has tree-sitter-clojure as a dependency) to build when I
   pointed the dependency for tree-sitter-clojure at a branch that had
   a symlink in it.  The error output was like:

    ```
    $ yarn
    yarn install v1.22.19
    [1/5] Validating package.json...
    warning parse-tree@0.24.0: The engine "vscode" appears to be invalid.
    [2/5] Resolving packages...
    [3/5] Fetching packages...
    error https://codeload.github.com/sogaiu/tree-sitter-clojure/tar.gz/d5c55b0d701a1f09bdb698c624489a57945f735d: Extracting tar content of undefined failed, the file appears to be corrupt: "ENOENT: no such file or directory, symlink '' -> '/home/user/.cache/yarn/v6/npm-tree-sitter-clojure-0.0.0-d5c55b0d701a1f09bdb698c624489a57945f735d/node_modules/tree-sitter-clojure/tree-sitter-clojure'"
    info Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.
    ```

   On a side note, some npm packages (projects) do [appear to contain
   symlinks](https://github.com/browserify/browserify/tree/master/test/symlink_dedupe/one),
   so it seems like having symlinks should be ok...

   Perhaps more recent versions of yarn will work better.  I didn't
   try the "modern" yarn, only something from the older 1.x series --
   apparently it was 1.22.19.  The point is moot though as I don't have
   control over what a user will choose to use.

May be there's some way to get the symlink to be created automatically
by the `Makefile`...or may be there can be a "setup script" that can
be run after cloning (perhaps there can be a "setup" target in the
Makefile).

I've opted to remove the symlink from the repository for now but as
hinted at above, the `Makefile` might be able to do useful things like
report on the presence / absence of the link with explanatory text,
for example.

### Reducing Dependence On Other Things

Some other pieces that seem to have become churny, complicated, and/or
side-effecty include:

* `emsdk`
* `Node.js`

#### emsdk

If we want to be able to continue to build `tree-sitter` as well as
grammar `.wasm` files, an alternative to `emsdk` would be necessary.
There may be options but I have not investigated them much.  One
candidate is [cheerp](https://github.com/leaningtech/cheerp-compiler).
There may be others.

However, if we don't use the playground, we can still build a version
of `tree-sitter` without that part being functional.  The playground
has definitely had uses (and may continue to be useful) even though I
don't typically use it currently, I think it's at least valuable to
develop a feel for tree-sitter as well as specific grammars.

#### Node.js

My impression is that Node.js seems to have had relatively speaking,
little regard for backward compatibility (though perhaps this is no
longer true?).  Another point is that they seem to insist on retiring
older versions within fairly short periods.

AFAIK, the only reason we need the `node` binary at this point is
because `tree-sitter` uses it to generate `src/parser.c` and friends.
I [tested out some
changes](https://github.com/tree-sitter/tree-sitter/issues/465#issuecomment-1371911897)
to `tree-sitter` that allowed use of quickjs instead.  Other
JavaScript runtimes may also work.

On a side note, ATM as part of installing `emsdk`, a version of `node`
is installed.  So currently it's probably possible to just use that
version of `node`.  On a related note, I tried out
[volta](https://volta.sh/).  So far it seems better than `nvm` as
AFAICT it will work on the usual 3 platforms (where as `nvm` only
works on 2 of the 3, since `nvm-windows` isn't the same as `nvm`).
### Unintegrated Content

XXX: about comments in json for rust:

https://github.com/serde-rs/json/issues/168
https://github.com/hjson/hjson-rust

XXX: npm package.json scripts info:

https://docs.npmjs.com/cli/v6/using-npm/scripts

XXX: npm package.json info:

https://docs.npmjs.com/cli/v6/configuring-npm/package-json

XXX: idea of having verbose mode for subcommands that reports which
     .so (by file path and other info) was used

XXX: idea of an option to subcommands to specify file path to .so
     to be used for language-specific processing

XXX: idea of a flag (or configuration item) to turn off scanning
